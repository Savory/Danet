[[{"l":"Welcome","p":["Danet is a framework heavily inspired by a NodeJS Framework called Nest. We aim to provide the same efficiency, but in Deno. Of course, Nest is way more mature, think of it as a hero that we look up to.","We borrow a lot from it, including documentation and sentences on this page, so please, definitely check it out because they deserve a lot of credit. Without Nest, we wouldn't be developing Danet.","Danet is a framework for building efficient, scalable Deno server-side applications. It is entirely build with Typescript.","Under the hood, Danet makes use of Oak. We might support other HTTP Web Framework in the future !","We abstract a lot of things so you can focus on your core business and architecture."]},{"l":"Philosophy","p":["Deno is a relatively new engine. Nest was one of the greatest framework to improve the architecture of NodeJS project. We want to bring the same level of pro-efficiency and professionalism into Deno's world.","Exactly like Nest, Danet provides an out-of-the-box application architecture which allows developers and teams to create highly testable, scalable, loosely coupled, and easily maintainable applications.","The architecture is the same as our hero, and it was originally heavily inspired by Angular."]},{"l":"Come with us on this awesome journey","p":["We always welcome contributors, feel free to submit a new feature or report a bug on our Github Repository and join our discord"]}],[{"l":"Controllers","p":["Controllers are responsible for handling incoming requests and returning responses to the client.","A controller's purpose is to receive specific requests for the application. The routing mechanism controls which controller receives which requests. Frequently, each controller has more than one route, and different routes can perform different actions.","In order to create a basic controller, we use classes and decorators. Decorators associate classes with required metadata and enable Danet to create a routing map (tie requests to the corresponding controllers)."]},{"l":"Routing","p":["In the following example we'll use the @Controller() decorator, which is required to define a basic controller. We'll specify an optional route path prefix of cats. Using a path prefix in a @Controller() decorator allows us to easily group a set of related routes, and minimize repetitive code. For example, we may choose to group a set of routes that manage interactions with a customer entity under the route /customers. In that case, we could specify the path prefix customers in the @Controller() decorator so that we don't have to repeat that portion of the path for each route in the file.","The @Get() HTTP request method decorator before the findAll() method tells Danet to create a handler for a specific endpoint for HTTP requests. The endpoint corresponds to the HTTP request method (GET in this case) and the route path. What is the route path? The route path for a handler is determined by concatenating the (optional) prefix declared for the controller, and any path specified in the method's decorator. Since we've declared a prefix for every route ( cats), and haven't added any path information in the decorator, Danet will map GET /cats requests to this handler. As mentioned, the path includes both the optional controller path prefix and any path string declared in the request method decorator. For example, a path prefix of customers combined with the decorator @Get('profile') would produce a route mapping for requests like GET /customers/profile.","In our example above, when a GET request is made to this endpoint, Danet routes the request to our user-defined findAll() method. Note that the method name we choose here is completely arbitrary. We obviously must declare a method to bind the route to, but Danet doesn't attach any significance to the method name chosen.","This method will return a 200 status code and the associated response, which in this case is just a string."]},{"l":"Request object","p":["Handlers often need access to the client request details. Danet provides access to the request object. We can access the request object by instructing Danet to inject it by adding the@Req() decorator to the handler's signature.","The request object represents the HTTP request and has properties for the request query string, parameters, HTTP headers, and body. In most cases, it's not necessary to grab these properties manually. We can use dedicated decorators instead, such as @Body() or @Query(), which are available out of the box. Below is a list of the provided decorators and the plain platform-specific objects they represent."]},{"l":"Resources","p":["Earlier, we defined an endpoint to fetch the cats resource ( GET route). We'll typically also want to provide an endpoint that creates new records. For this, let's create the POST handler:","It's that simple. Danet provides decorators for almost all of the standard HTTP methods: @Get(), @Post(), @Put(), @Delete(), @Patch(). In addition,@All() defines an endpoint that handles all of them."]},{"l":"Route parameters","p":["Routes with static paths won't work when you need to accept dynamic data as part of the request (e.g., GET /cats/1 to get cat with id 1). In order to define routes with parameters, we can add route parameter tokens in the path of the route to capture the dynamic value at that position in the request URL. The route parameter token in the @Get() decorator example below demonstrates this usage. Route parameters declared in this way can be accessed using the@Param() decorator, which should be added to the method signature.","@Param() is used to decorate a method parameter by giving a particular parameter token to the decorator.","Import Param from the https://deno.land/x/danet/mod.ts package."]},{"l":"Scopes","p":["For people coming from different programming language backgrounds, it might be unexpected to learn that in Danet, almost everything is shared across incoming requests. We have a connection pool to the database, singleton services with global state, etc.","However, there are edge-cases when request-based lifetime of the controller may be the desired behavior, for example request tracking or multi-tenancy. Documentation page will be created to explain how to do that."]},{"l":"Asynchronicity","p":["Being a modern framework, we know that data extraction is mostly asynchronous. That's why Danet supports and works well with async functions.","Learn more about async / await feature here","Every async function has to return a Promise. This means that you can return a deferred value that Danet will be able to resolve by itself. Let's see an example of this:"]},{"l":"Handling errors","p":["There's a separate chapter about handling errors (i.e., working with exceptions): Controllers"]},{"l":"Full resource sample","p":["Below is an example that makes use of several of the available decorators to create a basic controller. This controller exposes a couple of methods to access and manipulate internal data."]},{"l":"Getting up and running","p":["With the above controller fully defined, Danet still doesn't know that CatsController exists and as a result won't create an instance of this class.","Controllers always belong to a module, which is why we include the controllers array within the @Module() decorator. Since we haven't yet defined any other modules except the root AppModule, we'll use that to introduce the CatsController:","We attached the metadata to the module class using the @Module() decorator, and Danet can now easily reflect which controllers have to be mounted.","Now, it is time to create a DanetApplication that bootstrap our AppModule.","We advise you to create a bootstrap function that returns your DanetApplication instance, this will make testing easier as you can get your application instance and make it listen to a random port.","Run this function to get an application instance, and call listen method to run the server.","And finally execute this file with deno run --allow-net --unstable --allow-env run.ts"]}],[{"l":"Exception filters","p":["Danet comes with a built-in exceptions layer which is responsible for processing all unhandled exceptions across an application. When an exception is not handled by your application code, it is caught by this layer, which then automatically sends an appropriate user-friendly response.","Out of the box, this action is performed by a built-in global exception filter, which handles all exceptions. When an exception is unrecognized(does not have statusCode and message properties), the built-in exception filter generates the following default JSON response:","Any thrown exception containing the statusCode and message property will be properly populated and send back as a response (instead of the default InternalServerError for unrecognized exceptions)."]},{"l":"Built-in HTTP exceptions","p":["BadGatewayException","BadRequestException","ConflictException","Danet provides a set of standard exceptions that inherit from the base HttpException and represent many of the most common HTTP exceptions:","ForbiddenException","GatewayTimeoutException","GoneException","HttpVersionNotSupportedException","ImATeapotException","InternalServerErrorException","MethodNotAllowedException","NotAcceptableException","NotFoundException","NotImplementedException","PayloadTooLargeException","PreconditionFailedException","RequestTimeoutException","ServiceUnavailableException","UnauthorizedException","UnprocessableEntityException","UnsupportedMediaTypeException"]},{"l":"Exception filters","p":["While the base (built-in) exception filter can automatically handle many cases for you, you may want full control over the exceptions layer. For example, you may want to add logging or use a different JSON schema based on some dynamic factors. Exception filters are designed for exactly this purpose. They let you control the exact flow of control and the content of the response sent back to the client.","Let's create an exception filter that is responsible for catching exceptions which are an instance of the CustomException class, and implementing custom response logic for them.","The @Catch(CustomException) decorator binds the required metadata to the exception filter, telling Danet that this particular filter is looking for exceptions of type CustomException and nothing else. The @Catch() decorator takes a single parameter."]},{"l":"Binding filters","p":["Let's tie our new CustomExceptionFilter to the CatsController's create() method.","We have used the @UseFilters() decorator here. Similar to the @Catch() decorator, it takes the class of your filter, leaving responsibility for instantiation to the framework, and enabling dependency injection.","In the example above, the CustomException is applied only to the single create() route handler, making it method-scoped. Exception filters can be scoped at different levels: method-scoped, controller-scoped, or global-scoped. For example, to set up a filter as controller-scoped, you would do the following:","This construction sets up the CustomException for every route handler defined inside the CatsController."]},{"l":"Catch everything","p":["In order to catch every unhandled exception (regardless of the exception type), omit @Catch() decorator."]}],[{"l":"Guards","p":["A guard is a class annotated with the @Injectable() decorator, which implements the AuthGuard interface.","Guards have a single responsibility. They determine whether a given request will be handled by the route handler or not, depending on certain conditions (like permissions, roles, ACLs, etc.) present at run-time. This is often referred to as authorization."]},{"l":"Authorization guard","p":["As mentioned, authorization is a great use case for Guards because specific routes should be available only when the caller (usually a specific authenticated user) has sufficient permissions. The AuthGuard that we'll build now assumes an authenticated user (and that, therefore, a token is attached to the request headers). It will extract and validate the token, and use the extracted information to determine whether the request can proceed or not.","The logic inside the validateRequest() function can be as simple or sophisticated as needed. The main point of this example is to show how guards fit into the request/response cycle.","Every guard must implement a canActivate() function. This function should return a boolean, indicating whether the current request is allowed or not. It can return the response either synchronously or asynchronously via a Promise. Danet uses the return value to control the next action:","if it returns true, the request will be processed.","if it returns false, Danet will deny the request."]},{"l":"Binding guards","p":["Like pipes and exception filters, guards can be controller-scoped, method-scoped, or global-scoped. Below, we set up a controller-scoped guard using the @UseGuards() decorator. This decorator may take a single argument, or a comma-separated list of arguments. This lets you easily apply the appropriate set of guards with one declaration.","The construction above attaches the guard to every handler declared by this controller. If we wish the guard to apply only to a single method, we apply the @UseGuards() decorator at the method level.","Global guards are used across the whole application, for every controller and every route handler. You can set up a global guard using the following:"]}],[{"l":"Lifecycle","p":["A Danet application, as well as every application element, has a lifecycle managed by Danet. Danet provides lifecycle hooks that give visibility into key lifecycle events, and the ability to act (run registered code on your injectable or controller) when they occur."]},{"l":"Lifecycle events","p":["Lifecycle events happen during application bootstrapping and shutdown. Danet calls registered lifecycle hook methods on injectables and controllers at each of the following lifecycle events. As shown in the diagram above, Danet also calls the appropriate underlying methods to begin listening for connections, and to stop listening for connections.","OnAppClose is only triggered if you explicitly call app.close().","Lifecycle hook method","Lifecycle event triggering the hook method call","OnAppBootstrap()","Called once after all dependencies have been injected.","OnAppClose()","Called on app.close right before shutting down connections.","The lifecycle hooks listed above are not triggered for request-scoped classes. Request-scoped classes are not tied to the application lifecycle and their lifespan is unpredictable. They are exclusively created for each request and deleted after the response is sent."]},{"l":"Usage","p":["Each lifecycle hook is represented by an interface. Interfaces are technically optional because they do not exist after TypeScript compilation. Nonetheless, it's good practice to use them in order to benefit from strong typing and editor tooling. To register a lifecycle hook, implement the appropriate interface. For example, to register a method to be called after injections has been done on a particular class (e.g., Controller or Injectable), implement the OnAppBootstrap interface by supplying an onAppBootstrap() method, as shown below:"]},{"l":"Asynchronous initialization","p":["OnAppBootstrap hook allow you to defer the application initialization process (return a Promise or mark the method as async and await an asynchronous method completion in the method body)."]}],[{"l":"Rendering HTML","p":["Building API is cool, but sometime, we want to build a simple MVC app that will render HTML.","For this, Danet integrate the Handlebars templating engine."]},{"l":"Before writing any code"},{"i":"create-the-following-directory-at-your-projects-root","l":"Create the following directory at your project's root","p":["If you want to put these directory elsewhere, you can provide the path to views at runtime with app.setViewEngineDir('my/path/to/views);"]},{"i":"create-a-default-layout-called-mainhbs-with-the-following-content","l":"Create a default layout called main.hbs with the following content:"},{"i":"lets-render-things-now-","l":"Let's render things now !","p":["First, let's create your first template called hello.hbs in the views directory. It will print 2 variables passed from your controller.","Now, let's tell your controller it has to render this view on a specific route:","We specify the template to use with the @Render() decorator, and the return value of the route handler is passed to the template for rendering.","Notice that the return value is an object with title and name properties, matching title and name placeholders we used in the template."]}],[{"l":"Static files","p":["If you want your Danet app to serve static files from a specific folder, for example to serve a .png, you simply have to register the folder using useStaticAssets method from your DanetApplication instance as following :"]}],[{"l":"License"},{"l":"Danet Documentation","p":["Copyright 2022 Thomas Cruveilher","Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:","The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.","THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."]},{"l":"NestJs Documentation which we heavily copy content from","p":["Copyright (c) 2017-2022 Kamil My≈õliwiec http://kamilmysliwiec.com","Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the 'Software'), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:","The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.","THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."]}]]