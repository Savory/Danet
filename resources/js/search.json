[[{"l":"Welcome","p":["Danet is a framework heavily inspired by a NodeJS Framework called Nest. We aim to provide the same efficiency, but in Deno. Of course, Nest is way more mature, think of it as a hero that we look up to.","We borrow a lot from it, including documentation and sentences on this page, so please, definitely check it out because they deserve a lot of credit. Without Nest, we wouldn't be developing Danet.","Danet is a framework for building efficient, scalable Deno server-side applications. It is entirely build with Typescript.","Under the hood, Danet makes use of Oak. We might support other HTTP Web Framework in the future !","We abstract a lot of things so you can focus on your core business and architecture."]},{"l":"Philosophy","p":["Deno is a relatively new engine. Nest was one of the greatest framework to improve the architecture of NodeJS project. We want to bring the same level of pro-efficiency and professionalism into Deno's world.","Exactly like Nest, Danet provides an out-of-the-box application architecture which allows developers and teams to create highly testable, scalable, loosely coupled, and easily maintainable applications.","The architecture is the same as our hero, and it was originally heavily inspired by Angular."]},{"l":"Come with us on this awesome journey","p":["We always welcome contributors, feel free to submit a new feature or report a bug on our Github Repository and join our discord"]}],[{"l":"Controllers","p":["Controllers are responsible for handling incoming requests and returning responses to the client.","A controller's purpose is to receive specific requests for the application. The routing mechanism controls which controller receives which requests. Frequently, each controller has more than one route, and different routes can perform different actions.","In order to create a basic controller, we use classes and decorators. Decorators associate classes with required metadata and enable Danet to create a routing map (tie requests to the corresponding controllers)."]},{"l":"Routing","p":["In the following example we'll use the @Controller() decorator, which is required to define a basic controller. We'll specify an optional route path prefix of cats. Using a path prefix in a @Controller() decorator allows us to easily group a set of related routes, and minimize repetitive code. For example, we may choose to group a set of routes that manage interactions with a customer entity under the route /customers. In that case, we could specify the path prefix customers in the @Controller() decorator so that we don't have to repeat that portion of the path for each route in the file.","The @Get() HTTP request method decorator before the findAll() method tells Danet to create a handler for a specific endpoint for HTTP requests. The endpoint corresponds to the HTTP request method (GET in this case) and the route path. What is the route path? The route path for a handler is determined by concatenating the (optional) prefix declared for the controller, and any path specified in the method's decorator. Since we've declared a prefix for every route ( cats), and haven't added any path information in the decorator, Danet will map GET /cats requests to this handler. As mentioned, the path includes both the optional controller path prefix and any path string declared in the request method decorator. For example, a path prefix of customers combined with the decorator @Get('profile') would produce a route mapping for requests like GET /customers/profile.","In our example above, when a GET request is made to this endpoint, Danet routes the request to our user-defined findAll() method. Note that the method name we choose here is completely arbitrary. We obviously must declare a method to bind the route to, but Danet doesn't attach any significance to the method name chosen.","This method will return a 200 status code and the associated response, which in this case is just a string."]},{"l":"Request object","p":["Handlers often need access to the client request details. Danet provides access to the request object. We can access the request object by instructing Danet to inject it by adding the@Req() decorator to the handler's signature.","The request object represents the HTTP request and has properties for the request query string, parameters, HTTP headers, and body. In most cases, it's not necessary to grab these properties manually. We can use dedicated decorators instead, such as @Body() or @Query(), which are available out of the box. Below is a list of the provided decorators and the plain platform-specific objects they represent."]},{"l":"Resources","p":["Earlier, we defined an endpoint to fetch the cats resource ( GET route). We'll typically also want to provide an endpoint that creates new records. For this, let's create the POST handler:","It's that simple. Danet provides decorators for almost all of the standard HTTP methods: @Get(), @Post(), @Put(), @Delete(), @Patch(). In addition,@All() defines an endpoint that handles all of them."]},{"l":"Route parameters","p":["Routes with static paths won't work when you need to accept dynamic data as part of the request (e.g., GET /cats/1 to get cat with id 1). In order to define routes with parameters, we can add route parameter tokens in the path of the route to capture the dynamic value at that position in the request URL. The route parameter token in the @Get() decorator example below demonstrates this usage. Route parameters declared in this way can be accessed using the@Param() decorator, which should be added to the method signature.","@Param() is used to decorate a method parameter by giving a particular parameter token to the decorator."]},{"l":"Scopes","p":["For people coming from different programming language backgrounds, it might be unexpected to learn that in Danet, almost everything is shared across incoming requests. We have a connection pool to the database, singleton services with global state, etc.","However, there are edge-cases when request-based lifetime of the controller may be the desired behavior, for example request tracking or multi-tenancy. Documentation page will be created to explain how to do that."]},{"l":"Asynchronicity","p":["Being a modern framework, we know that data extraction is mostly asynchronous. That's why Danet supports and works well with async functions.","here!!!","Every async function has to return a Promise. This means that you can return a deferred value that Danet will be able to resolve by itself. Let's see an example of this:","There's a separate chapter about handling errors (i.e., working with exceptions): Controllers","Below is an example that makes use of several of the available decorators to create a basic controller. This controller exposes a couple of methods to access and manipulate internal data.","With the above controller fully defined, Danet still doesn't know that CatsController exists and as a result won't create an instance of this class.","Controllers always belong to a module, which is why we include the controllers array within the @Module() decorator. Since we haven't yet defined any other modules except the root AppModule, we'll use that to introduce the CatsController:","We attached the metadata to the module class using the @Module() decorator, and Danet can now easily reflect which controllers have to be mounted."]}],[{"l":"Exception filters","p":["BadGatewayException","BadRequestException","ConflictException","Danet comes with a built-in exceptions layer which is responsible for processing all unhandled exceptions across an application. When an exception is not handled by your application code, it is caught by this layer, which then automatically sends an appropriate user-friendly response.","Danet provides a set of standard exceptions that inherit from the base HttpException and represent many of the most common HTTP exceptions:","ForbiddenException","GatewayTimeoutException","GoneException","HttpVersionNotSupportedException","ImATeapotException","In order to catch every unhandled exception (regardless of the exception type), omit @Catch() decorator.","In the example above, the CustomException is applied only to the single create() route handler, making it method-scoped. Exception filters can be scoped at different levels: method-scoped, controller-scoped, or global-scoped. For example, to set up a filter as controller-scoped, you would do the following:","InternalServerErrorException","Let's create an exception filter that is responsible for catching exceptions which are an instance of the CustomException class, and implementing custom response logic for them.","Let's tie our new CustomExceptionFilter to the CatsController's create() method.","MethodNotAllowedException","NotAcceptableException","NotFoundException","NotImplementedException","Out of the box, this action is performed by a built-in global exception filter, which handles all exceptions. When an exception is unrecognized(does not have statusCode and message properties), the built-in exception filter generates the following default JSON response:","PayloadTooLargeException","PreconditionFailedException","property will be properly populated and send back as a response (instead of the default InternalServerError for unrecognized exceptions). !!!","RequestTimeoutException","ServiceUnavailableException","The @Catch(CustomException) decorator binds the required metadata to the exception filter, telling Danet that this particular filter is looking for exceptions of type CustomException and nothing else. The @Catch() decorator takes a single parameter.","This construction sets up the CustomException for every route handler defined inside the CatsController.","UnauthorizedException","UnprocessableEntityException","UnsupportedMediaTypeException","We have used the @UseFilters() decorator here. Similar to the @Catch() decorator, it takes the class of your filter, leaving responsibility for instantiation to the framework, and enabling dependency injection.","While the base (built-in) exception filter can automatically handle many cases for you, you may want full control over the exceptions layer. For example, you may want to add logging or use a different JSON schema based on some dynamic factors. Exception filters are designed for exactly this purpose. They let you control the exact flow of control and the content of the response sent back to the client."]}],[{"l":"Rendering HTML","p":["Building API is cool, but sometime, we want to build a simple MVC app that will render HTML.","For this, Danet integrate the Handlebars templating engine."]},{"l":"Before writing any code"},{"i":"create-the-following-directory-at-your-projects-root","l":"Create the following directory at your project's root","p":["path to views at runtime with app.setViewEngineDir('my/path/to/views);!!!","First, let's create your first template called hello.hbs in the views directory. It will print 2 variables passed from your controller.","Now, let's tell your controller it has to render this view on a specific route:","We specify the template to use with the @Render() decorator, and the return value of the route handler is passed to the template for rendering.","Notice that the return value is an object with title and name properties, matching title and name placeholders we used in the template."]}],[{"l":"License"},{"l":"Danet Documentation","p":["Copyright 2022 Thomas Cruveilher","Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:","The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.","THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."]},{"l":"NestJs Documentation which we heavily copy content from","p":["Copyright (c) 2017-2022 Kamil My≈õliwiec http://kamilmysliwiec.com","Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the 'Software'), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:","The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.","THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."]}]]