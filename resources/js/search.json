[[{"l":"Welcome","p":["Danet is a framework heavily inspired by a NodeJS Framework called Nest. We aim to provide the same efficiency, but in Deno. Of course, Nest is way more mature, think of it as a hero that we look up to.","We borrow a lot from it, including documentation and sentences on this page, so please, definitely check it out because they deserve a lot of credit. Without Nest, we wouldn't be developing Danet.","Danet is a framework for building efficient, scalable Deno server-side applications. It is entirely build with Typescript.","Under the hood, Danet makes use of Oak. We might support other HTTP Web Framework in the future !","We abstract a lot of things so you can focus on your core business and architecture."]},{"l":"Philosophy","p":["Deno is a relatively new engine. Nest was one of the greatest framework to improve the architecture of NodeJS project. We want to bring the same level of pro-efficiency and professionalism into Deno's world.","Exactly like Nest, Danet provides an out-of-the-box application architecture which allows developers and teams to create highly testable, scalable, loosely coupled, and easily maintainable applications.","The architecture is the same as our hero, and it was originally heavily inspired by Angular."]},{"l":"Come with us on this awesome journey","p":["We always welcome contributors, feel free to submit a new feature or report a bug on our Github Repository and join our discord","If you prefer to read one page tutorial, read our blog"]},{"l":"Sponsor","p":["A huge thanks to"]}],[{"l":"First steps","p":["In this set of articles, you'll learn the core fundamentals of Danet. To get familiar with the essential building blocks of Danet applications, we'll build a basic CRUD application with features that cover a lot of ground at an introductory level."]},{"l":"Prerequisites","p":["Please make sure that Deno(version >= Install v1.24.3) is installed on your operating system."]},{"l":"Setup","p":["The easiest way to set up a Danet project is by using our Danet CLI","First steps","The app is a TODO CRUD API with either MongoDB, Postgres or In-Memory database depending on what you choose when executing danet new command !"]},{"l":"Using MongoDB or Postgres","p":["To run the app, you need a database server running one or the other. We assume you know how to do that.","Then, you have to add your server's information somewhere so Danet can access these information to connect to the server.","You have 2 ways of doing so :"]},{"l":"Environment variables","p":["Add the following variables:","DB_NAME= DB_HOST= DB_PORT DB_USERNAME DB_PASSWORD="]},{"l":"Dotenv","p":["Danet has built-in dotenv support (because Deno support it natively), so you can create a .env file at your project's root the same variables :","We provide an .env.example file in the project"]},{"l":"Running the application","p":["Once the installation process is complete, you can run the following command at your OS command prompt to start the application listening for inbound HTTP requests:"]}],[{"l":"Controllers","p":["Controllers are responsible for handling incoming requests and returning responses to the client.","A controller's purpose is to receive specific requests for the application. The routing mechanism controls which controller receives which requests. Frequently, each controller has more than one route, and different routes can perform different actions.","In order to create a basic controller, we use classes and decorators. Decorators associate classes with required metadata and enable Danet to create a routing map (tie requests to the corresponding controllers)."]},{"l":"Routing","p":["In the following example we'll use the @Controller() decorator, which is required to define a basic controller. We'll specify an optional route path prefix of todo. Using a path prefix in a @Controller() decorator allows us to easily group a set of related routes, and minimize repetitive code. For example, we may choose to group a set of routes that manage interactions with a customer entity under the route /customers. In that case, we could specify the path prefix customers in the @Controller() decorator so that we don't have to repeat that portion of the path for each route in the file.","The @Get() HTTP request method decorator before the findAll() method tells Danet to create a handler for a specific endpoint for HTTP requests. The endpoint corresponds to the HTTP request method (GET in this case) and the route path. What is the route path? The route path for a handler is determined by concatenating the (optional) prefix declared for the controller, and any path specified in the method's decorator. Since we've declared a prefix for every route ( todo), and haven't added any path information in the decorator, Danet will map GET /todo requests to this handler. As mentioned, the path includes both the optional controller path prefix and any path string declared in the request method decorator. For example, a path prefix of customers combined with the decorator @Get('profile') would produce a route mapping for requests like GET /customers/profile.","In our example above, when a GET request is made to this endpoint, Danet routes the request to our user-defined findAll() method. Note that the method name we choose here is completely arbitrary. We obviously must declare a method to bind the route to, but Danet doesn't attach any significance to the method name chosen.","This method will return a 200 status code and the associated response, which in this case is just a string."]},{"l":"Request object","p":["{ [key: string]: string \\| string[] }","@Body(key?: string)","@Header(key? : string)","@Param(key: string)","@Query(key: string, options?: { value?: 'first' \\| 'last' \\| 'array' })","@Query(options?: { value?: 'first' \\| 'last' \\| 'array' })","@Req()","@Res()","any","context.params[key]","ctx.request","ctx.request.body/ ctx.request.body[key]","ctx.request.headers/ ctx.request.headers.get(key)","ctx.response","Decorator","Get the first, the last or all the values for all the query parameters","Get the first, the last or all the values for the query parameter named key","Handlers often need access to the client request details. Danet provides access to the request object. We can access the request object by instructing Danet to inject it by adding the@Req() decorator to the handler's signature.","oak.Request","oak.Response","string","string \\| string[]","string \\| undefined","The request object represents the HTTP request and has properties for the request query string, parameters, HTTP headers, and body. In most cases, it's not necessary to grab these properties manually. We can use dedicated decorators instead, such as @Body() or @Query(), which are available out of the box. Below is a list of the provided decorators and the plain platform-specific objects they represent.","Type","Value"]},{"l":"Resources","p":["Earlier, we defined an endpoint to fetch the todo resource ( GET route). We'll typically also want to provide an endpoint that creates new records. For this, let's create the POST handler:","It's that simple. Danet provides decorators for almost all of the standard HTTP methods: @Get(), @Post(), @Put(), @Delete(), @Patch(). In addition,@All() defines an endpoint that handles all of them."]},{"l":"Route parameters","p":["Routes with static paths won't work when you need to accept dynamic data as part of the request (e.g., GET /todo/1 to get todo with id 1). In order to define routes with parameters, we can add route parameter tokens in the path of the route to capture the dynamic value at that position in the request URL. The route parameter token in the @Get() decorator example below demonstrates this usage. Route parameters declared in this way can be accessed using the@Param() decorator, which should be added to the method signature.","@Param() is used to decorate a method parameter by giving a particular parameter token to the decorator.","Import Param from the https://deno.land/x/danet/mod.ts package."]},{"l":"Scopes","p":["For people coming from different programming language backgrounds, it might be unexpected to learn that in Danet, almost everything is shared across incoming requests. We have a connection pool to the database, singleton services with global state, etc.","However, there are edge-cases when request-based lifetime of the controller may be the desired behavior, for example request tracking or multi-tenancy. Documentation page will be created to explain how to do that."]},{"l":"Asynchronicity","p":["Being a modern framework, we know that data extraction is mostly asynchronous. That's why Danet supports and works well with async functions.","Learn more about async / await feature here","Every async function has to return a Promise. This means that you can return a deferred value that Danet will be able to resolve by itself. Let's see an example of this:"]},{"l":"Request payloads","p":["Our previous examples of the POST route handler didn't accept any client params. Let's fix this by adding the @Body() decorator here.","But first, we need to determine the DTO (Data Transfer Object) schema. A DTO is an object that defines how the data will be sent over the network. We determine the DTO schema by using simples classes with Type validation decorators. Danet uses Validatte to validate the Dto Schema with the body received. So, for each member of body you'll need to use a matching decorator for it.","You can see all the validation decorators avaibles here.","Let's create the CreateTodoDto class:","It has only three basic properties. Thereafter we can use the newly created DTO inside the TodoController:","If the body doesn't follow the DTO is returned a 400 status code. Like the example below:","More details about Body validation can be found here."]},{"l":"Handling errors","p":["There's a separate chapter about handling errors (i.e., working with exceptions): Controllers"]},{"l":"Full resource sample","p":["Below is an example that makes use of several of the available decorators to create a basic controller. This controller exposes a couple of methods to access and manipulate internal data."]},{"l":"Getting up and running","p":["With the above controller fully defined, Danet still doesn't know that TodoController exists and as a result won't create an instance of this class.","Controllers always belong to a module, which is why we include the controllers array within the @Module() decorator. Since we haven't yet defined any other modules except the root AppModule, we'll use that to introduce the TodoController:","We attached the metadata to the module class using the @Module() decorator, and Danet can now easily reflect which controllers have to be mounted.","Now, it is time to create a DanetApplication that bootstrap our AppModule.","We advise you to create a bootstrap function that returns your DanetApplication instance, this will make testing easier as you can get your application instance and make it listen to a random port.","Run this function to get an application instance, and call listen method to run the server.","And finally execute this file with deno run --allow-net --unstable --allow-env run.ts"]}],[{"l":"Injectables","p":["Injectables are a fundamental concept in Danet. Many of the basic Danet classes may be treated as a provider – services, repositories, factories, helpers, and so on. The main idea of a provider is that it can be injected as a dependency; this means objects can create various relationships with each other, and the function of \"wiring up\" instances of objects can largely be delegated to the Danet runtime system.","Image from nestjs documentation","In the previous chapter, we built a simple TodoController. Controllers should handle HTTP requests and delegate more complex tasks to injectables. Injectables are plain JavaScript classes that are declared as injectables in a","Injectables.","info Hint Since Danet enables the possibility to design and organize dependencies in a more OO way, we strongly recommend following the SOLID principles."]},{"l":"Services","p":["Let's start by creating a simple TodoService. This service will be responsible for data storage and retrieval, and is designed to be used by the TodoController, so it's a good candidate to be defined as a provider.","Our TodoService is a basic class with one property and two methods. The only new feature is that it uses the @Injectable() decorator. The @Injectable() decorator attaches metadata, which declares that TodoService is a class that can be managed by the Danet IoC container. By the way, this example also uses a Todo interface, which probably looks something like this:","Now that we have a service class to retrieve todos, let's use it inside the TodoController:","The TodoService is injected through the class constructor. Notice the use of the private syntax. This shorthand allows us to both declare and initialize the todoService member immediately in the same location."]},{"l":"Dependency injection","p":["Danet is built around the strong design pattern commonly known as Dependency injection. We recommend reading a great article about this concept in the official Angular documentation.","In Danet, thanks to TypeScript capabilities, it's extremely easy to manage dependencies because they are resolved just by type. In the example below, Danet will resolve the todoService by creating and returning an instance of TodoService(or, in the normal case of a singleton, returning the existing instance if it has already been requested elsewhere). This dependency is resolved and passed to your controller's constructor (or assigned to the indicated property):"]},{"l":"Scopes","p":["Injectables normally have a lifetime (\"scope\") synchronized with the application lifecycle. When the application is bootstrapped, every dependency must be resolved, and therefore every provider has to be instantiated. Similarly, when the application shuts down, each provider will be destroyed. However, there are ways to make your provider lifetime request-scoped as well. You can read more about these techniques on the following page!fundamentals"]},{"l":"Provider registration","p":["Now that we have defined a provider ( TodoService), and we have a consumer of that service ( TodoController), we need to register the service with Danet so that it can perform the injection. We do this by editing our module file ( app.module.ts) and adding the service to the injectables array of the @Module() decorator.","Danet will now be able to resolve the dependencies of the TodoController class."]}],[{"l":"Modules","p":["A module is a class annotated with a @Module() decorator. The @Module() decorator provides metadata that Danet makes use of to organize the application structure.","Each application has at least one module, a root module. The root module is the starting point Danet uses to build the application graph- the internal data structure Danet uses to resolve module and provider relationships and dependencies. While very small applications may theoretically have just the root module, this is not the typical case. We want to emphasize that modules are strongly recommended as an effective way to organize your components. Thus, for most applications, the resulting architecture will employ multiple modules, each declaring a closely related set of capabilities.","The @Module() decorator takes a single object whose properties describe the module:","injectables","the injectables that will be instantiated by the Danet injector and that may be shared at least across this module","controllers","the set of controllers defined in this module which have to be instantiated","imports","the list of imported modules that declare the injectables which are required in this module","The module does not encapsulate injectables. This means that you can inject injectables from any module as long as it has been resolved.","This will change in the future."]},{"l":"Feature modules","p":["The TodoController and TodoService belong to the same application domain. As they are closely related, it makes sense to move them into a feature module. A feature module simply organizes code relevant for a specific feature, keeping code organized and establishing clear boundaries. This helps us manage complexity and develop with SOLID principles, especially as the size of the application and/or team grow.","To demonstrate this, we'll create the TodoModule.","Above, we defined the TodoModule in the todo.module.ts file, and moved everything related to this module into the todo directory. The last thing we need to do is import this module into the root module (the AppModule, defined in the app.module.ts file)."]},{"l":"Shared modules","p":["In Danet, modules are singletons by default, and thus you can share the same instance of any provider between multiple modules effortlessly.","Every module is automatically a shared module. Once created it can be reused by any module. Let's imagine that we want to share an instance of the TodoService between several other modules. In order to do that, nothing has to be done, any module that imports the TodoModule has access to the TodoService and will share the same instance with all other modules that import it as well."]},{"l":"Global modules","p":["Like in Angular injectables are registered in the global scope. Once defined, they're available everywhere."]}],[{"l":"Middlewares","p":["Middleware is a function which is called before the route handler. Middleware functions have access to oak's context object.","You implement custom Danet middleware in either a function, or in a class with an @Injectable() decorator. The class should implement the DanetMiddleware interface, while the function does not have any special requirements. Let's start by implementing a simple middleware feature using the class method."]},{"l":"Dependency injection","p":["Danet middleware fully supports Dependency Injection. Just as with injectables and controllers, they are able to inject dependencies that are available within the same module. As usual, this is done through the constructor."]},{"l":"Applying middleware","p":["You can apply middlewares either globally, to controllers and to methods.","For global middlewares simply use addGlobalMiddlewares DanetApplication's method as following:","For controllers and methods, simply use @Middleware decorator ! Like addGlobalMiddlewares, it can take as many middleware are you need for arguments."]},{"l":"Functional middleware","p":["The LoggerMiddleware class we've been using is quite simple. It has no members, no additional methods, and no dependencies. Why can't we just define it in a simple function instead of a class? In fact, we can. This type of middleware is called functional middleware. Let's transform the logger middleware from class-based into functional middleware to illustrate the difference:","And use it within the TodoController:","Consider using the simpler functional middleware alternative any time your middleware doesn't need any dependencies."]},{"l":"Multiple middleware","p":["As mentioned above, in order to bind multiple middleware that are executed sequentially, simply provide them in left to right order to @Middleware or addGlobalMiddleware."]},{"l":"Global middleware","p":["If we want to bind middleware to every registered route at once, simply use addGlobalMiddlewares DanetApplication's method as following:"]}],[{"l":"Exception filters","p":["Danet comes with a built-in exceptions layer which is responsible for processing all unhandled exceptions across an application. When an exception is not handled by your application code, it is caught by this layer, which then automatically sends an appropriate user-friendly response.","Out of the box, this action is performed by a built-in global exception filter, which handles all exceptions. When an exception is unrecognized(does not have statusCode and message properties), the built-in exception filter generates the following default JSON response:","Any thrown exception containing the statusCode and message property will be properly populated and send back as a response (instead of the default InternalServerError for unrecognized exceptions)."]},{"l":"Built-in HTTP exceptions","p":["BadGatewayException","BadRequestException","ConflictException","Danet provides a set of standard exceptions that inherit from the base HttpException and represent many of the most common HTTP exceptions:","ForbiddenException","GatewayTimeoutException","GoneException","HttpVersionNotSupportedException","ImATeapotException","InternalServerErrorException","MethodNotAllowedException","NotAcceptableException","NotFoundException","NotImplementedException","PayloadTooLargeException","PreconditionFailedException","RequestTimeoutException","ServiceUnavailableException","UnauthorizedException","UnprocessableEntityException","UnsupportedMediaTypeException"]},{"l":"Exception filters","p":["While the base (built-in) exception filter can automatically handle many cases for you, you may want full control over the exceptions layer. For example, you may want to add logging or use a different JSON schema based on some dynamic factors. Exception filters are designed for exactly this purpose. They let you control the exact flow of control and the content of the response sent back to the client.","Let's create an exception filter that is responsible for catching exceptions which are an instance of the CustomException class, and implementing custom response logic for them.","The @Catch(CustomException) decorator binds the required metadata to the exception filter, telling Danet that this particular filter is looking for exceptions of type CustomException and nothing else. The @Catch() decorator takes a single parameter."]},{"l":"Binding filters","p":["Let's tie our new CustomExceptionFilter to the TodoController's create() method.","We have used the @UseFilters() decorator here. Similar to the @Catch() decorator, it takes the class of your filter, leaving responsibility for instantiation to the framework, and enabling dependency injection.","In the example above, the CustomException is applied only to the single create() route handler, making it method-scoped. Exception filters can be scoped at different levels: method-scoped, controller-scoped, or global-scoped. For example, to set up a filter as controller-scoped, you would do the following:","This construction sets up the CustomException for every route handler defined inside the TodoController."]},{"l":"Catch everything","p":["In order to catch every unhandled exception (regardless of the exception type), omit @Catch() decorator."]}],[{"l":"Guards","p":["A guard is a class annotated with the @Injectable() decorator, which implements the AuthGuard interface.","Guards have a single responsibility. They determine whether a given request will be handled by the route handler or not, depending on certain conditions (like permissions, roles, ACLs, etc.) present at run-time. This is often referred to as authorization."]},{"l":"Authorization guard","p":["As mentioned, authorization is a great use case for Guards because specific routes should be available only when the caller (usually a specific authenticated user) has sufficient permissions. The AuthGuard that we'll build now assumes an authenticated user (and that, therefore, a token is attached to the request headers). It will extract and validate the token, and use the extracted information to determine whether the request can proceed or not.","The logic inside the validateRequest() function can be as simple or sophisticated as needed. The main point of this example is to show how guards fit into the request/response cycle.","Every guard must implement a canActivate() function. This function should return a boolean, indicating whether the current request is allowed or not. It can return the response either synchronously or asynchronously via a Promise. Danet uses the return value to control the next action:","if it returns true, the request will be processed.","if it returns false, Danet will deny the request."]},{"l":"Binding guards","p":["Like pipes and exception filters, guards can be controller-scoped, method-scoped, or global-scoped. Below, we set up a controller-scoped guard using the @UseGuards() decorator. This decorator may take a single argument, or a comma-separated list of arguments. This lets you easily apply the appropriate set of guards with one declaration.","The construction above attaches the guard to every handler declared by this controller. If we wish the guard to apply only to a single method, we apply the @UseGuards() decorator at the method level.","Global guards are used across the whole application, for every controller and every route handler. You can set up a global guard using the following:"]}],[{"l":"Rendering HTML","p":["Building API is cool, but sometime, we want to build a simple MVC app that will render HTML.","For this, Danet integrate the Handlebars templating engine."]},{"l":"Before writing any code"},{"i":"create-the-following-directory-at-your-projects-root","l":"Create the following directory at your project's root","p":["If you want to put these directory elsewhere, you can provide the path to views at runtime with app.setViewEngineDir('my/path/to/views);"]},{"i":"create-a-default-layout-called-mainhbs-with-the-following-content","l":"Create a default layout called main.hbs with the following content:"},{"i":"lets-render-things-now-","l":"Let's render things now !","p":["First, let's create your first template called hello.hbs in the views directory. It will print 2 variables passed from your controller.","Now, let's tell your controller it has to render this view on a specific route:","We specify the template to use with the @Render() decorator, and the return value of the route handler is passed to the template for rendering.","Notice that the return value is an object with title and name properties, matching title and name placeholders we used in the template."]}],[{"l":"Static files","p":["If you want your Danet app to serve static files from a specific folder, for example to serve a .png, you simply have to register the folder using useStaticAssets method from your DanetApplication instance as following :"]}],[{"l":"Injection scopes","p":["For people coming from different programming language backgrounds, it might be unexpected to learn that in Danet, almost everything is shared across incoming requests. We have a connection pool to the database, singleton services with global state, etc. Remember that Node.js doesn't follow the request/response Multi-Threaded Stateless Model in which every request is processed by a separate thread. Hence, using singleton instances is fully safe for our applications.","However, there are edge-cases when request-based lifetime may be the desired behavior, for instance per-request caching in GraphQL applications, request tracking, and multi-tenancy. Injection scopes provide a mechanism to obtain the desired provider lifetime behavior."]},{"l":"Provider scope","p":["A provider can have any of the following scopes:","Using singleton scope is recommended for most use cases. Sharing providers across consumers and across requests means that an instance can be cached and its initialization occurs only once, during application startup."]},{"l":"Usage","p":["Specify injection scope by passing the scope property to the @Injectable() decorator options object:","Singleton scope is used by default, and need not be declared. If you do want to declare a provider as singleton scoped, use the Scope.GLOBAL value for the scope property."]},{"l":"Controller scope","p":["Controllers can also have scope, which applies to all request method handlers declared in that controller. Like provider scope, the scope of a controller declares its lifetime. For a request-scoped controller, a new instance is created for each inbound request, and garbage-collected when the request has completed processing.","Declare controller scope with the scope property of the ControllerOptions object:"]},{"l":"Scope hierarchy","p":["The REQUEST scope bubbles up the injection chain. A controller that depends on a request-scoped provider will, itself, be request-scoped.","Imagine the following dependency graph: TodoController - TodoService - TodoRepository. If TodoService is request-scoped (and the others are default singletons), the TodoController will become request-scoped as it is dependent on the injected service. The TodoRepository, which is not dependent, would remain singleton-scoped."]},{"l":"Access context","p":["You may want to access a reference to the original request object when using request-scoped providers. You can access it using the beforeControllerMethodIsCalled method as following. And yes, it can be async."]},{"l":"Performance","p":["Using request-scoped providers will have an impact on application performance. We have to create an instance of your class on each request. Hence, it will slow down your average response time and overall benchmarking result. Unless a provider must be request-scoped, it is strongly recommended that you use the default singleton scope.","Although it all sounds quite intimidating, a properly designed application that leverages request-scoped providers should not slow down by more than ~ 5% latency-wise."]}],[{"l":"Lifecycle","p":["A Danet application, as well as every application element, has a lifecycle managed by Danet. Danet provides lifecycle hooks that give visibility into key lifecycle events, and the ability to act (run registered code on your injectable or controller) when they occur."]},{"l":"Lifecycle events","p":["Lifecycle events happen during application bootstrapping and shutdown. Danet calls registered lifecycle hook methods on injectables and controllers at each of the following lifecycle events. As shown in the diagram above, Danet also calls the appropriate underlying methods to begin listening for connections, and to stop listening for connections.","OnAppClose is only triggered if you explicitly call app.close().","Lifecycle hook method","Lifecycle event triggering the hook method call","OnAppBootstrap()","Called once after all dependencies have been injected.","OnAppClose()","Called on app.close right before shutting down connections.","The lifecycle hooks listed above are not triggered for request-scoped classes. Request-scoped classes are not tied to the application lifecycle and their lifespan is unpredictable. They are exclusively created for each request and deleted after the response is sent."]},{"l":"Usage","p":["Each lifecycle hook is represented by an interface. Interfaces are technically optional because they do not exist after TypeScript compilation. Nonetheless, it's good practice to use them in order to benefit from strong typing and editor tooling. To register a lifecycle hook, implement the appropriate interface. For example, to register a method to be called after injections has been done on a particular class (e.g., Controller or Injectable), implement the OnAppBootstrap interface by supplying an onAppBootstrap() method, as shown below:"]},{"l":"Asynchronous initialization","p":["OnAppBootstrap hook allow you to defer the application initialization process (return a Promise or mark the method as async and await an asynchronous method completion in the method body)."]}],[{"l":"CORS","p":["Cross-origin resource sharing (CORS) is a mechanism that allows resources to be requested from another domain."]},{"l":"Usage","p":["As Danet uses Oak under the hood, you can use oak_cors package.","Then, apply its middleware as global middleware (for example, in your bootstrap.ts file).","Feel free to use any other cors middleware you like"]}],[{"l":"Sessions","p":["HTTP sessions provide a way to store information about the user across multiple requests."]},{"l":"Usage","p":["As Danet uses Oak under the hood, you can use oak_sessions package.","Then, apply the oak_sessions middleware as global middleware (for example, in your bootstrap.ts file).","The default server-side session storage is purposely not designed for a production environment. It is meant for debugging and developing. Read more in the official repository."]},{"l":"With cookies","p":["Oak_session use Stores to store session data in Cookies, Sqlite, Mongodb or Postgres. The simpliest way to handle sessions is with cookies using CookieStore:"]},{"l":"Session decorator","p":["You can access the session in your routes using @Session decorator. oak_session's Session is basically a map, so we use the Map type."]}],[{"l":"Compression","p":["Compression can greatly decrease the size of the response body, thereby increasing the speed of a web app.","For high-traffic websites in production, it is strongly recommended to offload compression from the application server - typically in a reverse proxy (e.g., Nginx). In that case, you should not use compression middleware."]},{"l":"Usage","p":["As Danet uses Oak under the hood, you can use oak_compress package.","Then, apply its middleware as global middleware (for example, in your bootstrap.ts file).","Feel free to use any other compression middleware you like"]}],[{"l":"Introduction","p":["The OpenAPI specification is a language-agnostic definition format used to describe RESTful APIs. Danet provides a dedicated module which allows generating such a specification by leveraging decorators.","The SwaggerModule is currently in Alpha, maaaany features are missing. If something you need is not here yet, please fill an issue/feature request"]},{"l":"Bootstrap","p":["Simply open the bootstrap.ts file and initialize Swagger using the SwaggerModule class:","document(returned by the SwaggerModule#createDocument() method) is a serializable object conforming to OpenAPI Document. Instead of hosting it via HTTP, you could also save it as a JSON/YAML file, and consume it in different ways.","The SpecBuilder helps to structure a base document that conforms to the OpenAPI Specification. It provides several methods that allow setting such properties as title, description, version, etc. In order to create a full document (with all HTTP routes defined) we use the createDocument() method of the SwaggerModule class. This method takes two arguments, an application instance and a Swagger options object.","Once we create a document, we can call the setup() method. It accepts:","The path to mount the Swagger UI","An application instance","The document object instantiated above","Now you can run the following command to start the HTTP server:","While the application is running, open your browser and navigate to http://localhost:3000/api. You should see the Swagger UI.","image","The SwaggerModule automatically reflects all of your endpoints.","To generate and download a Swagger JSON file, navigate to http://localhost:3000/api/json(assuming that your Swagger documentation is available under http://localhost:3000/api)."]}],[{"l":"Types and Parameters","p":["The SwaggerModule is currently in Alpha, maaaany features are missing. If something you need is not here yet, please fill an issue/feature request"]},{"i":"body-query-and-params","l":"Body, Query and Params","p":["The SwaggerModule searches for all @Body() and @Query() decorators in route handlers to generate the API document. It also creates corresponding model definitions by taking advantage of reflection. Consider the following code:","To explicitly set the body definition use the @BodyType(Todo) decorator. To explicitly set the query definition use the @QueryType(Todo) decorator.","Based on the Todo, the following model definition Swagger UI will be created: image","In order to make the class properties visible to the SwaggerModule, we have to annotate them with the @ApiProperty() decorator :","If one of these property is optional, you can use @Optional() decorator.","Let's open the browser and verify the generated Todo model:","image"]},{"l":"Return type","p":["Due to SWC (Deno's typescript compiler) lacking design:return metadata, you must use the @ReturnedType decorator to say what your endpoint will return :","If your route returns an array, pass true as the second argument of ReturnedType:"]},{"l":"Enums","p":["To identify an enum, we must manually set the enum property on the @ApiProperty with an array of values."]}],[{"l":"Operations","p":["In OpenAPI terms, paths are endpoints (resources), such as /users or /reports/summary, that your API exposes, and operations are the HTTP methods used to manipulate these paths, such as GET, POST or DELETE.","The SwaggerModule is currently in Alpha, maaaany features are missing. If something you need is not here yet, please fill an issue/feature request"]},{"l":"Tags","p":["To attach a controller or an endpoint to a specific tag, use the @Tag(tagName) decorator."]}],[{"l":"Security"},{"l":"Security","p":["To define which security mechanisms should be used for a specific operation, use the @ApiSecurity() decorator.","Before you run your application, remember to add the security definition to your base document using SpecBuilder:","Some of the most popular authentication techniques are built-in (e.g., basic and bearer) and therefore you don't have to define security mechanisms manually as shown above."]},{"l":"Basic authentication","p":["To enable basic authentication, use @ApiBasicAuth().","Add the security definition to your base document using SpecBuilder:"]},{"l":"Bearer authentication","p":["To enable bearer authentication, use @ApiBearerAuth().","Before you run your application, remember to add the security definition to your base document using SpecBuilder:"]},{"l":"OAuth2 authentication","p":["To enable OAuth2, use @ApiOAuth2().","Before you run your application, remember to add the security definition to your base document using SpecBuilder:"]},{"l":"Cookie authentication","p":["To enable cookie authentication, use @ApiCookieAuth().","Before you run your application, remember to add the security definition to your base document using SpecBuilder:"]}],[{"l":"CLI"},{"l":"Overview","p":["The Danet CLI is a command-line interface tool that helps you to initialize your Danet applications.","In the future, it will assist in multiple ways, including scaffolding the project, serving it in development mode, and building and bundling the application for production distribution. It embodies best-practice architectural patterns to encourage well-structured apps."]},{"l":"Installation","p":["Installing Deno packages as a commands is simple. You can install them under any name you want. For simplicity's sake, we install our danet-cli under the name danet."]},{"l":"Basic workflow","p":["Once installed, you can invoke CLI commands directly from your OS command line through the danet command. See the available danet commands by entering the following:","To create, run a new basic Danet project, go to the folder that should be the parent of your new project, and run the following commands:","In your browser, open http://localhost:3000 to see the new application running."]},{"l":"Database Options","p":["When creating a new project, Danet CLI will ask you what database provider you want to use between mongodb, postgres and in-memory and will generate all the required code.","The only thing left if you use mongodb or postgres will be to set environment variables or put them in a .env file in your project's root folder.","However, if you need it to be less interactive, you can pass the followings options when calling danet new:","--mongodb","--postgres","--in-memory"]}],[{"l":"License"},{"l":"Danet Documentation","p":["Copyright 2022 Thomas Cruveilher","Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:","The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.","THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."]},{"l":"NestJs Documentation which we heavily copy content from","p":["Copyright (c) 2017-2022 Kamil Myśliwiec http://kamilmysliwiec.com","Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the 'Software'), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:","The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.","THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."]}]]